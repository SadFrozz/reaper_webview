#!/usr/bin/env python3
import sys
import os
import glob
from pathlib import Path

# Usage: python compile_resources.py <input_dir> <output_h> <output_cpp>
if len(sys.argv) < 4:
    print("Usage: python compile_resources.py <input_dir> <output_h> <output_cpp>")
    sys.exit(1)

input_dir = Path(sys.argv[1]).resolve()
output_h_path = Path(sys.argv[2])
output_cpp_path = Path(sys.argv[3])

png_files = sorted(glob.glob(str(input_dir / '**' / '*.png'), recursive=True))
if not png_files:
    print(f"No png files found in {input_dir}")

# Sanitize name -> enumerator (имя_расширение)
def to_enum_name(p: Path) -> str:
    rel = p.relative_to(input_dir).as_posix()  # e.g. icons/foo.png
    name = rel.replace('/', '_')
    name = name.lower()
    # leave dot for extension conversion to _
    name = name.replace('.', '_')  # foo_png
    # Ensure starts with letter or underscore
    if not (name[0].isalpha() or name[0] == '_'):
        name = '_' + name
    # Collapse duplicate underscores
    while '__' in name:
        name = name.replace('__', '_')
    return name

# Header generation
header = [
    '#pragma once',
    '#include <cstddef>',
    '',
    '// Auto-generated by compile_resources.py. DO NOT EDIT MANUALLY.',
    'struct EmbeddedResource { const unsigned char* data; std::size_t size; const char* name; };',
    '',
]

enum_lines = ['enum EmbeddedResId {']
for idx, f in enumerate(png_files):
    enum_lines.append(f'  {to_enum_name(Path(f))} = {idx},')

enum_lines.append('  EmbeddedResId_Count')
enum_lines.append('};')

header.extend(enum_lines)
header.append('')
header.append('const EmbeddedResource* GetEmbeddedResource(EmbeddedResId id);')
header.append('const EmbeddedResource* GetEmbeddedResourceByName(const char* name);')
header.append('')

output_h_path.parent.mkdir(parents=True, exist_ok=True)
output_h_path.write_text('\n'.join(header) + '\n', encoding='utf-8')

# CPP generation
cpp = [f'#include "{output_h_path.name}"', '#include <cstring>', '', '// Auto-generated implementation', '']
resources_entries = []

for f in png_files:
    path_obj = Path(f)
    enum_name = to_enum_name(path_obj)
    rel = path_obj.relative_to(input_dir).as_posix()  # preserve folder if any
    data = path_obj.read_bytes()
    arr_name = f'_res_bytes_{enum_name}'
    cpp.append(f'static const unsigned char {arr_name}[] = {{')
    line = '    '
    for i, b in enumerate(data):
        line += f'0x{b:02x}, '
        if (i+1) % 16 == 0:
            cpp.append(line)
            line = '    '
    if line.strip():
        cpp.append(line)
    cpp.append('};')
    cpp.append(f'static const EmbeddedResource _res_{enum_name} = {{{arr_name}, sizeof({arr_name}), "{rel}"}};')
    cpp.append('')
    resources_entries.append(f'&_res_{enum_name}')

cpp.append('static const EmbeddedResource* const g_all_resources[] = {')
for e in resources_entries:
    cpp.append(f'  {e},')
cpp.append('};')
cpp.append('')

cpp.append('const EmbeddedResource* GetEmbeddedResource(EmbeddedResId id) {')
cpp.append('  if (id < 0 || id >= EmbeddedResId_Count) return nullptr;')
cpp.append('  return g_all_resources[(int)id];')
cpp.append('}')
cpp.append('')
cpp.append('const EmbeddedResource* GetEmbeddedResourceByName(const char* name) {')
cpp.append('  if(!name) return nullptr;')
cpp.append('  for (int i=0; i<EmbeddedResId_Count; ++i){')
cpp.append('    const EmbeddedResource* r = g_all_resources[i];')
cpp.append('    if (r && std::strcmp(r->name, name) == 0) return r;')
cpp.append('  }')
cpp.append('  return nullptr;')
cpp.append('}')
cpp.append('')

output_cpp_path.parent.mkdir(parents=True, exist_ok=True)
output_cpp_path.write_text('\n'.join(cpp) + '\n', encoding='utf-8')

print(f"Embedded {len(png_files)} PNG resources -> {output_h_path} , {output_cpp_path}")
